<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>משחק דו-שחקני – כדור ומחבטים</title>
<style>
  :root{
    --bg:#0b1020; --text:#eaf0ff; --accent:#6ea8fe; --accent2:#70e1a1; --danger:#ff8686;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,"Segoe UI",Arial;
    overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none;
  }

  /* === מסך המשחק – מסך מלא === */
  #screenGame{
    position:fixed; inset:0; display:none;
    background:radial-gradient(120% 120% at 50% 0%, #0f1533 0%, #0b1020 60%);
    overflow:hidden;
  }
  #stage{ width:100vw; height:100vh; display:block; }

  /* אפקטים: חץ + "מפסידן" */
  .fx{
    position:fixed; left:0; right:0; display:none;
    pointer-events:none; justify-content:center; align-items:center; gap:12px;
    font-weight:700;
  }
  .fx.top{ top:12vh; flex-direction:column }
  .fx.bot{ bottom:12vh; flex-direction:column }
  .arrow{ font-size:44px; line-height:1 }
  .lose{ font-size:28px; color:var(--danger); text-shadow:0 4px 16px rgba(0,0,0,.45) }
  .fadePop{ animation:fadePop 2.5s ease forwards }
  @keyframes fadePop{
    0%{opacity:0; transform:scale(.85)}
    10%{opacity:1; transform:scale(1.05)}
    100%{opacity:0; transform:scale(1)}
  }

  /* שכבת זוכה סופית: רק חץ + "והמנצח הוא שחקן X" */
  #winnerLayer{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    text-align:center; gap:8px; background:rgba(0,0,0,.25); backdrop-filter:blur(2px);
  }
  #winnerArrow{ font-size:64px; margin-bottom:8px }
  #winnerText{ font-size:22px; margin:0 }

  /* === מסך פתיחה (בחירת כמות משחקונים) === */
  #screenStart{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35); backdrop-filter:blur(3px);
  }
  .startCard{
    background:#121734; padding:18px; border-radius:16px; width:min(92vw,420px);
    display:flex; flex-direction:column; gap:12px; text-align:center;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
  }
  .row{ display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap }
  label{ opacity:.9 }
  .num{
    appearance:none; padding:10px 14px; border-radius:12px; border:none;
    background:#0f1533; color:var(--text); font-size:16px;
  }
  button{
    cursor:pointer; padding:12px 18px; border:none; border-radius:12px; font-size:16px;
    background:linear-gradient(135deg,var(--accent),#5e7fe8); color:#fff;
  }
  button:active{ transform:translateY(1px) }
</style>
</head>
<body>

  html, body { overscroll-behavior: none; }
<!-- מסך פתיחה -->
<section id="screenStart">
  <div class="startCard">
    <div class="row">
      <label for="roundsSel">כמות משחקונים:</label>
      <select id="roundsSel" class="num">
        <option>3</option><option selected>5</option><option>7</option><option>9</option>
        <option>11</option><option>13</option><option>15</option>
      </select>
    </div>
    <button id="btnStart">שחק</button>
  </div>
</section>

<!-- מסך משחק – מסך מלא, ללא טקסטים -->
<section id="screenGame">
  <canvas id="stage"></canvas>

  <!-- הודעת הפסד זמנית (עם חץ הפוך – מצביע אל המפסיד) -->
  <div id="fxTop" class="fx top">
    <div class="arrow">⬆️</div>
    <div class="lose">מפסידן</div>
  </div>
  <div id="fxBot" class="fx bot">
    <div class="arrow">⬇️</div>
    <div class="lose">מפסידן</div>
  </div>

  <!-- שכבת זוכה סופית (חץ שמצביע על המנצח + "והמנצח הוא") -->
  <div id="winnerLayer">
    <div>
      <div id="winnerArrow">⬆️</div>
      <p id="winnerText">והמנצח הוא שחקן עליון</p>
    </div>
  </div>
</section>

<!-- סאונד -->
<audio id="sndLose" src="lose.mp3" preload="auto"></audio>
<audio id="sndWin"  src="win.mp3"  preload="auto"></audio>

<script>
(function(){
  // ===== DOM =====
  const startScreen = document.getElementById('screenStart');
  const btnStart    = document.getElementById('btnStart');
  const roundsSel   = document.getElementById('roundsSel');

  const gameScreen  = document.getElementById('screenGame');
  const canvas      = document.getElementById('stage');
  const ctx         = canvas.getContext('2d');

  const fxTop = document.getElementById('fxTop');
  const fxBot = document.getElementById('fxBot');

  const winnerLayer = document.getElementById('winnerLayer');
  const winnerArrow = document.getElementById('winnerArrow');
  const winnerText  = document.getElementById('winnerText');

  const sndLose = document.getElementById('sndLose');
  const sndWin  = document.getElementById('sndWin');

  // ===== מצב =====
  let running=false, rafId=null;
  let totalRounds=5, playedRounds=0;
  let scoreTop=0, scoreBot=0;
  let servingTo='top';

  // מהירות/האצה
  let minSpeed = 0, maxSpeed = 0, accelPerSec = 0;
  let lastTime = 0; // ms

  const ball = { x:0, y:0, r:10, vx:0, vy:0, speed:0 }; // vx,vy בפיקסלים/שניה
  const padTop = { x:0, y:0, w:0, h:0 };
  const padBot = { x:0, y:0, w:0, h:0 };
  const T = { stemW:0, stemH:0, barW:0, barH:0, circleR:0 };

  // ===== עזרים =====
  function lockOrientation(){
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(()=>{});
    }
  }
  async function goFullscreen(){
    const el = document.documentElement;
    try{
      if (el.requestFullscreen) {
        await el.requestFullscreen({ navigationUI: 'hide' });
      } else if (el.webkitRequestFullscreen) {
        el.webkitRequestFullscreen();
      }
    }catch(e){}
  }

  // מניעת Pull-to-Refresh/גלילה
  let __startY = 0;
  document.addEventListener('touchstart', (e)=>{
    if (e.touches && e.touches.length) __startY = e.touches[0].clientY;
  }, {passive:false});
  document.addEventListener('touchmove', (e)=>{
    if (!e.touches || !e.touches.length) return;
    const y = e.touches[0].clientY;
    const pullingDown = (y - __startY) > 0;
    const atTop = (document.scrollingElement ? document.scrollingElement.scrollTop : window.scrollY) <= 0;
    if (pullingDown && atTop) e.preventDefault();
  }, {passive:false});

  // חסימת F5 / Ctrl+R
  window.addEventListener("keydown", function(e){
    if (e.key === "F5" || (e.ctrlKey && e.key.toLowerCase() === "r")) {
      e.preventDefault();
    }
  });

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function setCanvasSize(){
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    const dpr  = Math.max(1, window.devicePixelRatio || 1);

    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // פרופורציות מחבט
    const pw = Math.max(80, Math.round(cssW*0.28));
    const ph = Math.max(22, Math.round(cssH*0.04));
    padTop.w = pw; padTop.h = ph;
    padBot.w = pw; padBot.h = ph;
    padTop.x = cssW/2;
    padBot.x = cssW/2;

    // חלקי ה-T
    T.stemW   = Math.max(10, Math.round(pw*0.18));
    T.stemH   = Math.max(14, Math.round(ph*1.6));
    T.barW    = Math.max(36, Math.round(pw*0.7));
    T.barH    = Math.max(10, Math.round(ph*0.7));
    T.circleR = Math.max(8,  Math.round(ph*0.8));

    // מרחק בטוח מהקצה כדי שכל ה-T ייראה
    const fullTHeight = T.barH + T.stemH + T.circleR*2;
    const margin      = Math.max(18, Math.round(cssH*0.02));
    padTop.y = (fullTHeight/2) + margin;
    padBot.y = cssH - (fullTHeight/2) - margin;
  }

  function resetBall(){
    const cw = canvas.clientWidth, ch = canvas.clientHeight;
    ball.x = cw/2;
    ball.y = ch/2;

    // מהירות התחלתית איטית + מקסימום גבוה + תאוצה הדרגתית
    const base = Math.max(160, cw * 0.42); // פיקסלים לשניה (לא פר פריים)
    minSpeed   = base;
    maxSpeed   = base * 4.5;
    accelPerSec= (maxSpeed - minSpeed) / 10; // להגיע למקסימום ~10 שניות
    ball.speed = minSpeed;

    const dirY  = (servingTo==='top') ? -1 : 1;
    const angle = (Math.random()*0.5 - 0.25); // הטייה קלה
    const vx = Math.sin(angle) * ball.speed;
    const vy = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx)) * dirY;
    ball.vx = vx; // px/s
    ball.vy = vy; // px/s

    lastTime = performance.now();
  }

  // ציור מחבט T הפוך (עיגול לצד החיצוני)
  function drawPaddle(pad, isTop){
    const x = pad.x, y = pad.y;
    ctx.save(); ctx.translate(0.5,0.5); ctx.fillStyle = '#6ea8fe';
    // קו אופקי
    ctx.fillRect(x - T.barW/2, y - T.barH/2, T.barW, T.barH);
    if (isTop){
      const stemX = x - T.stemW/2;
      const stemY = y - T.barH/2 - T.stemH;
      ctx.fillRect(stemX, stemY, T.stemW, T.stemH);
      ctx.beginPath(); ctx.arc(x, stemY - T.circleR, T.circleR, 0, Math.PI*2); ctx.fill();
    } else {
      const stemX = x - T.stemW/2;
      const stemY = y + T.barH/2;
      ctx.fillRect(stemX, stemY, T.stemW, T.stemH);
      ctx.beginPath(); ctx.arc(x, stemY + T.stemH + T.circleR, T.circleR, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawBall(){
    ctx.save();
    ctx.fillStyle = '#70e1a1';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function clear(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  }

  function update(dt){
    const cw = canvas.clientWidth, ch = canvas.clientHeight;

    // האצה הדרגתית
    ball.speed = Math.min(ball.speed + accelPerSec * dt, maxSpeed);

    // תנועה (px/s * s)
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // נורמליזציה למהירות החדשה
    const mag = Math.hypot(ball.vx, ball.vy);
    if (mag > 0){
      const f = ball.speed / mag;
      ball.vx *= f;
      ball.vy *= f;
    }

    // קירות שמאל/ימין
    if (ball.x - ball.r <= 0 && ball.vx < 0){ ball.x = ball.r; ball.vx *= -1; }
    if (ball.x + ball.r >= cw && ball.vx > 0){ ball.x = cw - ball.r; ball.vx *= -1; }

    // התנגשות עם המחבט העליון (הגוף כלפי מעלה)
    const topRect = {
      x: padTop.x - T.barW/2,
      y: padTop.y - (T.barH/2 + T.stemH + T.circleR*2),
      w: T.barW,
      h: T.barH + T.stemH + T.circleR*2
    };
    if (ball.vy < 0 &&
        ball.y - ball.r <= topRect.y + topRect.h &&
        ball.y > topRect.y &&
        ball.x >= topRect.x && ball.x <= topRect.x + topRect.w){
      ball.y = topRect.y + topRect.h + ball.r;
      const hit = ((ball.x - padTop.x) / (T.barW/2)); // -1..1
      const ang = hit * 0.6;
      const vx  = Math.sin(ang) * ball.speed;
      const vy  = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx));
      ball.vx = vx; ball.vy = +vy; // קופץ למטה
    }

    // התנגשות עם המחבט התחתון (הגוף כלפי מטה)
    const botRect = {
      x: padBot.x - T.barW/2,
      y: padBot.y - T.barH/2,
      w: T.barW,
      h: T.barH + T.stemH + T.circleR*2
    };
    if (ball.vy > 0 &&
        ball.y + ball.r >= botRect.y &&
        ball.y < botRect.y + botRect.h &&
        ball.x >= botRect.x && ball.x <= botRect.x + botRect.w){
      ball.y = botRect.y - ball.r;
      const hit = ((ball.x - padBot.x) / (T.barW/2));
      const ang = hit * 0.6;
      const vx  = Math.sin(ang) * ball.speed;
      const vy  = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx));
      ball.vx = vx; ball.vy = -vy; // קופץ למעלה
    }

    // יציאה למעלה/למטה => הפסד
    if (ball.y + ball.r < 0){
      pointTo('bot'); // עליון הפסיד, תחתון מקבל נקודה
    } else if (ball.y - ball.r > ch){
      pointTo('top'); // תחתון הפסיד, עליון מקבל נקודה
    }
  }

  function render(){
    clear();
    drawPaddle(padTop, true);
    drawPaddle(padBot, false);
    drawBall();
  }

  function loop(){
    if (!running) return;
    const now = performance.now();
    const dt  = Math.max(0, (now - lastTime) / 1000);
    lastTime  = now;

    update(dt);
    render();
    rafId = requestAnimationFrame(loop);
  }

  function showLoseFx(loserSide){ // 'top' או 'bot'
    const el = (loserSide==='top') ? fxTop : fxBot;
    el.style.display = 'flex';
    el.classList.remove('fadePop'); void el.offsetWidth; // reset
    el.classList.add('fadePop');
    setTimeout(()=>{ el.style.display='none'; }, 2500);
  }

  function pointTo(whoGetsPoint){ // 'top' מקבל נקודה או 'bot'
    running = false; cancelAnimationFrame(rafId);
    playedRounds++;
    if (whoGetsPoint==='top') scoreTop++; else scoreBot++;

    // הצג "מפסידן" בצד שנכשל
    showLoseFx(whoGetsPoint==='top' ? 'bot' : 'top');
    try{ sndLose.currentTime=0; sndLose.play().catch(()=>{});}catch(e){}

    // סוף סט?
    const over = (playedRounds >= totalRounds);
    if (over){
      if (scoreTop === scoreBot){
        // הארכה
        totalRounds++;
        servingTo = (Math.random()<0.5) ? 'top' : 'bot';
        setTimeout(startRally, 2500);
      } else {
        setTimeout(showWinner, 800);
      }
      return;
    }

    // הסרב הבא ישוגר לכיוון המפסיד
    servingTo = (whoGetsPoint==='top') ? 'bot' : 'top';
    setTimeout(startRally, 2500);
  }

  function showWinner(){
    const topWon = (scoreTop > scoreBot);
    winnerArrow.textContent = topWon ? '⬆️' : '⬇️'; // מצביע על המנצח
    winnerText.textContent  = topWon ? 'והמנצח הוא שחקן עליון' : 'והמנצח הוא שחקן תחתון';
    winnerLayer.style.display = 'flex';
    try{ sndWin.currentTime=0; sndWin.play().catch(()=>{});}catch(e){}
  }

  function startMatch(){
    scoreTop=0; scoreBot=0; playedRounds=0;
    totalRounds = parseInt(roundsSel.value, 10) || 5;

    winnerLayer.style.display = 'none';
    setCanvasSize();
    resetBall();
    running = true;
    loop();
  }

  function startRally(){
    resetBall();
    running = true;
    loop();
  }

  // ===== שליטה – נגיעה/החלקה להזזת מחבטים =====
  function pointerX(clientX){
    const rect = canvas.getBoundingClientRect();
    return clamp(clientX - rect.left, 0, rect.width);
  }
  function onTouch(ev){
    const rect = canvas.getBoundingClientRect();
    for (const t of ev.touches){
      const cx = pointerX(t.clientX);
      const cy = t.clientY - rect.top;
      if (cy < rect.height/2){ padTop.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
      else { padBot.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
    }
    ev.preventDefault();
  }
  function onMouse(ev){
    if (ev.buttons !== 1) return;
    const rect = canvas.getBoundingClientRect();
    const cx = pointerX(ev.clientX);
    const cy = ev.clientY - rect.top;
    if (cy < rect.height/2){ padTop.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
    else { padBot.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
  }

  // ===== אירועים =====
  btnStart.addEventListener('click', async ()=>{
    lockOrientation();
    await goFullscreen();
    startScreen.style.display='none';
    gameScreen.style.display='block';
    startMatch();
  });

  winnerLayer.addEventListener('click', ()=>{
    winnerLayer.style.display='none';
    gameScreen.style.display='none';
    startScreen.style.display='flex';
  });

  window.addEventListener('resize', ()=>{ if (gameScreen.style.display!=='none') setCanvasSize(); });
  canvas.addEventListener('touchstart', onTouch, {passive:false});
  canvas.addEventListener('touchmove',  onTouch, {passive:false});
  canvas.addEventListener('mousedown', onMouse);
  canvas.addEventListener('mousemove', onMouse);
})();
  </script>
</body>
</html>
