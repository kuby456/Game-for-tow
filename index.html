<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>משחק דו-שחקני – כדור ומחבטים</title>
<style>
  :root{
    --bg:#0b1020; --text:#eaf0ff; --accent:#6ea8fe; --accent2:#70e1a1; --danger:#ff8686;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,"Segoe UI",Arial;
    overflow:hidden; touch-action:none; -webkit-user-select:none; user-select:none;
  }

  /* === מסך המשחק – מסך מלא === */
  #screenGame{
    position:fixed; inset:0; display:none;
    background:radial-gradient(120% 120% at 50% 0%, #0f1533 0%, #0b1020 60%);
    overflow:hidden;
  }
  #stage{ width:100vw; height:100vh; display:block; }

  /* אפקטים: חץ + "מפסידן" */
  .fx{
    position:fixed; left:0; right:0; display:none;
    pointer-events:none; justify-content:center; align-items:center; gap:12px;
    font-weight:700;
  }
  .fx.top{ top:12vh; flex-direction:column }
  .fx.bot{ bottom:12vh; flex-direction:column }
  .arrow{ font-size:44px; line-height:1 }
  .lose{ font-size:28px; color:var(--danger); text-shadow:0 4px 16px rgba(0,0,0,.45) }
  .fadePop{ animation:fadePop 2.5s ease forwards }
  @keyframes fadePop{
    0%{opacity:0; transform:scale(.85)}
    10%{opacity:1; transform:scale(1.05)}
    100%{opacity:0; transform:scale(1)}
  }

  /* שכבת זוכה סופית: רק חץ + "והמנצח הוא שחקן X" */
  #winnerLayer{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    text-align:center; gap:8px; background:rgba(0,0,0,.25); backdrop-filter:blur(2px);
  }
  #winnerArrow{ font-size:64px; margin-bottom:8px }
  #winnerText{ font-size:22px; margin:0 }

  /* === מסך פתיחה (בחירת כמות משחקונים) === */
  #screenStart{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35); backdrop-filter:blur(3px);
  }
  .startCard{
    background:#121734; padding:18px; border-radius:16px; width:min(92vw,420px);
    display:flex; flex-direction:column; gap:12px; text-align:center;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
  }
  .row{ display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap }
  label{ opacity:.9 }
  .num{
    appearance:none; padding:10px 14px; border-radius:12px; border:none;
    background:#0f1533; color:var(--text); font-size:16px;
  }
  button{
    cursor:pointer; padding:12px 18px; border:none; border-radius:12px; font-size:16px;
    background:linear-gradient(135deg,var(--accent),#5e7fe8); color:#fff;
  }
  button:active{ transform:translateY(1px) }
</style>
</head>
<body>

  html, body { overscroll-behavior: none; }
<!-- מסך פתיחה -->
<section id="screenStart">
  <div class="startCard">
    <div class="row">
      <label for="roundsSel">כמות משחקונים:</label>
      <select id="roundsSel" class="num">
        <option>3</option><option selected>5</option><option>7</option><option>9</option>
        <option>11</option><option>13</option><option>15</option>
      </select>
    </div>
    <button id="btnStart">שחק</button>
  </div>
</section>

<!-- מסך משחק – מסך מלא, ללא טקסטים -->
<section id="screenGame">
  <canvas id="stage"></canvas>

  <!-- הודעת הפסד זמנית (עם חץ הפוך – מצביע אל המפסיד) -->
  <div id="fxTop" class="fx top">
    <div class="arrow">⬆️</div>
    <div class="lose">מפסידן</div>
  </div>
  <div id="fxBot" class="fx bot">
    <div class="arrow">⬇️</div>
    <div class="lose">מפסידן</div>
  </div>

  <!-- שכבת זוכה סופית (חץ שמצביע על המנצח + "והמנצח הוא") -->
  <div id="winnerLayer">
    <div>
      <div id="winnerArrow">⬆️</div>
      <p id="winnerText">והמנצח הוא שחקן עליון</p>
    </div>
  </div>
</section>

<!-- סאונד -->
<audio id="sndLose" src="lose.mp3" preload="auto"></audio>
<audio id="sndWin"  src="win.mp3"  preload="auto"></audio>

<script>
(function(){
  // DOM
  const startScreen = document.getElementById('screenStart');
  const btnStart    = document.getElementById('btnStart');
  const roundsSel   = document.getElementById('roundsSel');

  const gameScreen  = document.getElementById('screenGame');
  const canvas      = document.getElementById('stage');
  const ctx         = canvas.getContext('2d');

  const fxTop = document.getElementById('fxTop');
  const fxBot = document.getElementById('fxBot');

  const winnerLayer = document.getElementById('winnerLayer');
  const winnerArrow = document.getElementById('winnerArrow');
  const winnerText  = document.getElementById('winnerText');

  const sndLose = document.getElementById('sndLose');
  const sndWin  = document.getElementById('sndWin');

  // מצב
  let running=false, rafId=null;
  let totalRounds=5, playedRounds=0;
  let scoreTop=0, scoreBot=0;
  let servingTo='top';
  let minSpeed = 0, maxSpeed = 0, accelPerSec = 0;
let lastTime = 0;

  const ball = { x:0, y:0, r:10, vx:0, vy:0, speed:0 };
  const padTop = { x:0, y:0, w:0, h:0 };
  const padBot = { x:0, y:0, w:0, h:0 };
  const T = { stemW:0, stemH:0, barW:0, barH:0, circleR:0 };

  // עוזר
  function lockOrientation(){
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(()=>{});
    }
  }
  function setCanvasSize(){
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;
  const dpr  = Math.max(1, window.devicePixelRatio || 1);

  canvas.style.width  = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // פרופורציות מחבט
  const pw = Math.max(80, Math.round(cssW*0.28));
  const ph = Math.max(22, Math.round(cssH*0.04));
  padTop.w = pw; padTop.h = ph;
  padBot.w = pw; padBot.h = ph;
  padTop.x = cssW/2; 
  padBot.x = cssW/2;

  // חלקי ה-T
  T.stemW   = Math.max(10, Math.round(pw*0.18));
  T.stemH   = Math.max(14, Math.round(ph*1.6));
  T.barW    = Math.max(36, Math.round(pw*0.7));
  T.barH    = Math.max(10, Math.round(ph*0.7));
  T.circleR = Math.max(8,  Math.round(ph*0.8));

  // *** חשוב: מרחק "בטוח" מהקצה לפי גובה ה-T המלא + שוליים ***
  const fullTHeight = T.barH + T.stemH + T.circleR*2; // גובה ה-T כולל העיגול
  const margin      = Math.max(18, Math.round(cssH*0.02)); // שוליים קטנים

  // המחבט העליון צריך להיות לגמרי גלוי מעל – לכן ה-y שלו = גובה ה-T + שוליים
  padTop.y = (fullTHeight/2) + margin;

  // המחבט התחתון צריך להיות לגמרי גלוי מתחת – לכן מרחק מהתחתית
  padBot.y = cssH - (fullTHeight/2) - margin;
}
  function resetBall(){
  const cw = canvas.clientWidth, ch = canvas.clientHeight;
  ball.x = cw/2; 
  ball.y = ch/2;

  // מהירות בסיסית איטית (מתואמת רוחב), מקסימום מהיר מאוד
  const base = Math.max(2.4, cw * 0.0042);
  minSpeed   = base;
  maxSpeed   = base * 4.5;        // כמה מהר מאוד להגיע (אפשר לשנות יחסית)
  accelPerSec= (maxSpeed - minSpeed) / 10; // זמן עד מקסימום ~10 שניות
  ball.speed = minSpeed;

  const dirY  = (servingTo==='top') ? -1 : 1;
  const angle = (Math.random()*0.5 - 0.25); // סטייה קלה לשמאל/ימין
  const vx = Math.sin(angle) * ball.speed;
  const vy = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx)) * dirY;
  ball.vx = vx; 
  ball.vy = vy;

  lastTime = performance.now(); // איפוס מד זמן לפריים הבא
}
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ציור מחבט T הפוך (עיגול “מהצד החיצוני”)
  function drawPaddle(pad, isTop){
    const x = pad.x, y = pad.y;
    ctx.save(); ctx.translate(0.5,0.5); ctx.fillStyle = '#6ea8fe';
    // קו אופקי
    ctx.fillRect(x - T.barW/2, y - T.barH/2, T.barW, T.barH);
    if (isTop){
      // העליון – גזע ועיגול עולים למעלה
      const stemX = x - T.stemW/2;
      const stemY = y - T.barH/2 - T.stemH;
      ctx.fillRect(stemX, stemY, T.stemW, T.stemH);
      ctx.beginPath(); ctx.arc(x, stemY - T.circleR, T.circleR, 0, Math.PI*2); ctx.fill();
    } else {
      // התחתון – גזע ועיגול יורדים למטה
      const stemX = x - T.stemW/2;
      const stemY = y + T.barH/2;
      ctx.fillRect(stemX, stemY, T.stemW, T.stemH);
      ctx.beginPath(); ctx.arc(x, stemY + T.stemH + T.circleR, T.circleR, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  function drawBall(){
    ctx.save();
    ctx.fillStyle = '#70e1a1';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function clear(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  }

  // לוגיקה
  function loop(){
  if (!running) return;
  const now = performance.now();
  const dt  = Math.max(0, (now - lastTime) / 1000); // שניות
  lastTime  = now;

  update(dt);
  render();
  rafId = requestAnimationFrame(loop);
}

function update(dt){
  const cw = canvas.clientWidth, ch = canvas.clientHeight;

  // האצה הדרגתית עד מקסימום
  ball.speed = Math.min(ball.speed + accelPerSec * dt, maxSpeed);

  // תנועה
  ball.x += ball.vx;
  ball.y += ball.vy;

  // נורמליזציה למהירות החדשה
  const mag = Math.hypot(ball.vx, ball.vy);
  if (mag !== 0){
    const f = ball.speed / mag;
    ball.vx *= f; 
    ball.vy *= f;
  }

  // קירות צד
  if (ball.x - ball.r <= 0 && ball.vx < 0){ ball.x = ball.r; ball.vx *= -1; }
  if (ball.x + ball.r >= cw && ball.vx > 0){ ball.x = cw - ball.r; ball.vx *= -1; }

  // *** התנגשות עם מחבט עליון (כפי שכבר אצלך – הפוך) ***
  const topRect = {
    x: padTop.x - T.barW/2,
    y: padTop.y - (T.barH/2 + T.stemH + T.circleR*2),
    w: T.barW,
    h: T.barH + T.stemH + T.circleR*2
  };
  if (ball.vy < 0 &&
      ball.y - ball.r <= topRect.y + topRect.h &&
      ball.y > topRect.y &&
      ball.x >= topRect.x && ball.x <= topRect.x + topRect.w){
    ball.y = topRect.y + topRect.h + ball.r;
    const hit = ((ball.x - padTop.x) / (T.barW/2));
    const ang = hit * 0.6;
    const vx  = Math.sin(ang) * ball.speed;
    const vy  = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx));
    ball.vx = vx; ball.vy = +vy; // למטה
  }

  // *** התנגשות עם מחבט תחתון (כפי שכבר אצלך – הפוך) ***
  const botRect = {
    x: padBot.x - T.barW/2,
    y: padBot.y - T.barH/2,
    w: T.barW,
    h: T.barH + T.stemH + T.circleR*2
  };
  if (ball.vy > 0 &&
      ball.y + ball.r >= botRect.y &&
      ball.y < botRect.y + botRect.h &&
      ball.x >= botRect.x && ball.x <= botRect.x + botRect.w){
    ball.y = botRect.y - ball.r;
    const hit = ((ball.x - padBot.x) / (T.barW/2));
    const ang = hit * 0.6;
    const vx  = Math.sin(ang) * ball.speed;
    const vy  = Math.sqrt(Math.max(0.0001, ball.speed*ball.speed - vx*vx));
    ball.vx = vx; ball.vy = -vy; // למעלה
  }

  // יציאה למעלה/למטה => הפסד
  if (ball.y + ball.r < 0){
    pointTo('bot'); // העליון הפסיד
  } else if (ball.y - ball.r > ch){
    pointTo('top'); // התחתון הפסיד
  }
}
  function render(){
    clear();
    drawPaddle(padTop, true);
    drawPaddle(padBot, false);
    drawBall();
  }
  

  function showLoseFx(loserSide){ // 'top' או 'bot'
    const el = (loserSide==='top') ? fxTop : fxBot;
    el.style.display = 'flex';
    el.classList.remove('fadePop'); void el.offsetWidth; // reset
    el.classList.add('fadePop');
    setTimeout(()=>{ el.style.display='none'; }, 2500);
  }

  function pointTo(whoGetsPoint){ // 'top' מקבל נקודה או 'bot'
    running = false; cancelAnimationFrame(rafId);
    playedRounds++;
    if (whoGetsPoint==='top') scoreTop++; else scoreBot++;

    // הצג מפסידן (ההפך ממי שקיבל נקודה)
    showLoseFx(whoGetsPoint==='top' ? 'bot' : 'top');
    try{ sndLose.currentTime=0; sndLose.play().catch(()=>{});}catch(e){}

    // הסתיים סט?
    const over = (playedRounds >= totalRounds);
    if (over){
      // שוויון – הארכת משחקון
      if (scoreTop === scoreBot){
        totalRounds++;
        servingTo = (Math.random()<0.5) ? 'top' : 'bot';
        setTimeout(startRally, 2500);
      } else {
        setTimeout(showWinner, 800);
      }
      return;
    }
    // סרב הבא – נשלח לכיוון המפסיד כדי לא ליפול פעמיים רצוף
    servingTo = (whoGetsPoint==='top') ? 'bot' : 'top';
    setTimeout(startRally, 2500);
  }

  function showWinner(){
    const topWon = (scoreTop > scoreBot);
    winnerArrow.textContent = topWon ? '⬆️' : '⬇️'; // מצביע על המנצח
    winnerText.textContent  = topWon ? 'והמנצח הוא שחקן עליון' : 'והמנצח הוא שחקן תחתון';
    winnerLayer.style.display = 'flex';
    try{ sndWin.currentTime=0; sndWin.play().catch(()=>{});}catch(e){}
  }

  function startMatch(){
    scoreTop=0; scoreBot=0; playedRounds=0;
    totalRounds = parseInt(roundsSel.value, 10) || 5;

    setCanvasSize();
    resetBall();
    running = true;
    loop();
  }
  function startRally(){
    resetBall();
    running = true;
    loop();
  }

  // שליטה – נגיעה/החלקה להזזת מחבטים
  function pointerX(clientX){
    const rect = canvas.getBoundingClientRect();
    return clamp(clientX - rect.left, 0, rect.width);
  }
  function onTouch(ev){
    const rect = canvas.getBoundingClientRect();
    for (const t of ev.touches){
      const cx = pointerX(t.clientX);
      const cy = t.clientY - rect.top;
      if (cy < rect.height/2){ padTop.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
      else { padBot.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
    }
    ev.preventDefault();
  }
  function onMouse(ev){
    if (ev.buttons !== 1) return;
    const rect = canvas.getBoundingClientRect();
    const cx = pointerX(ev.clientX);
    const cy = ev.clientY - rect.top;
    if (cy < rect.height/2){ padTop.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
    else { padBot.x = clamp(cx, T.barW/2, rect.width - T.barW/2); }
  }

  // אירועים
  btnStart.addEventListener('click', ()=>{
    lockOrientation();
    startScreen.style.display='none';
    gameScreen.style.display='block';
    startMatch();
  });

  // הקלקה בכל מקום אחרי ניצחון – חזרה למסך פתיחה
  winnerLayer.addEventListener('click', ()=>{
    winnerLayer.style.display='none';
    gameScreen.style.display='none';
    startScreen.style.display='flex';
  });

  window.addEventListener('resize', ()=>{ if (gameScreen.style.display!=='none') setCanvasSize(); });
  canvas.addEventListener('touchstart', onTouch, {passive:false});
  canvas.addEventListener('touchmove',  onTouch, {passive:false});
  canvas.addEventListener('mousedown', onMouse);
  canvas.addEventListener('mousemove', onMouse);
})();
  
  async function goFullscreen() {
  const el = document.documentElement;
  try {
    // נסיון להסתיר UI ניווט של הדפדפן (תלוי דפדפן)
    if (el.requestFullscreen) {
      await el.requestFullscreen({ navigationUI: 'hide' });
    } else if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
    }
  } catch(e){}
}

btnStart.addEventListener('click', async ()=>{
  lockOrientation();
  await goFullscreen(); // <-- הוסף שורה זו
  startScreen.style.display='none';
  gameScreen.style.display='block';
  startMatch();
});
</script>
</body>
</html>
